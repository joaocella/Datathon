# -*- coding: utf-8 -*-
"""FIX recrutamento_pro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k3mwSuWrT-UNtcsna87FYhkFjJpcUIgR

# --- PARTE 1: CONFIGURA√á√ÉO INICIAL E IMPORTA√á√ÉO DE BIBLIOTECAS ---
"""

# --- PARTE 1: CONFIGURA√á√ÉO INICIAL E IMPORTA√á√ÉO DE BIBLIOTECAS ---

# --- PARTE 1: INSTALA√á√ÉO E CONFIGURA√á√ÉO INICIAL ---
# 1.1. Instala√ß√£o de Bibliotecas

# 1.2. Importa√ß√£o de Bibliotecas Essenciais
import pandas as pd
import json
import os
from datetime import datetime
import joblib
import numpy as np
from sklearn.linear_model import LogisticRegression
from sqlalchemy import create_engine, Column, String, Integer, DateTime, Text
from sqlalchemy.orm import sessionmaker, declarative_base
import sqlite3

# 1.3. Configura√ß√£o do Banco de Dados SQLite
Base = declarative_base()

class Candidatura(Base):
    __tablename__ = 'candidaturas'
    id = Column(Integer, primary_key=True, autoincrement=True)
    vaga = Column(String(255))
    nome = Column(String(255))
    email = Column(String(255))
    linkedin = Column(String(255))
    experiencia = Column(String(50))
    escolaridade = Column(String(50))
    nivel_ingles = Column(String(50))
    nivel_espanhol = Column(String(50))
    habilidades = Column(Text)  # NOVO CAMPO ADICIONADO
    cv = Column(String(255))
    data_hora = Column(DateTime)

# Criar banco de dados e tabela
engine = create_engine('sqlite:///candidatos.db')
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

# 1.4. Carregar ou criar dados de vagas em formato unificado
SOURCE_FILE = "vagas.json"
TARGET_FILE = "jobs_sample.json"

if not os.path.exists(SOURCE_FILE):
    print(f"‚ùå Arquivo '{SOURCE_FILE}' n√£o encontrado. Criando dados dummy alternativos em '{TARGET_FILE}'...")

    dummy_jobs_data = {
        "vaga_999": {
            "titulo": "Dummy Backup",
            "cliente": "Sistema",
            "perfil_vaga": {
                "cidade": "S√£o Paulo",
                "estado": "SP",
                "pais": "Brasil",
                "nivel_profissional": "S√™nior",
                "nivel_ingles": "Avan√ßado",
                "nivel_espanhol": "Intermedi√°rio",
                "competencias": ["Python", "SQL", "Backup"],
                "atividades": ["Manuten√ß√£o do sistema", "Backup de dados"]
            }
        }
    }
    with open(TARGET_FILE, "w", encoding="utf-8") as f:
        json.dump(dummy_jobs_data, f, indent=4, ensure_ascii=False)
    print(f"‚úÖ '{TARGET_FILE}' criado com dados dummy de backup")
else:
    try:
        with open(SOURCE_FILE, "r", encoding="utf-8") as f:
            vagas_data = json.load(f)

        jobs_data = {}
        for vid, det in vagas_data.items():
            perfil = det.get("perfil_vaga", {})
            # extrair listas de compet√™ncias e atividades
            comps = perfil.get("competencia_tecnicas_e_comportamentais", "")
            atvs = perfil.get("principais_atividades", "")
            lista_comps = [c.strip() for c in comps.split("\n") if c.strip()] if isinstance(comps, str) else comps
            lista_atvs  = [a.strip() for a in atvs.split("\n") if a.strip()] if isinstance(atvs, str) else atvs

            jobs_data[f"vaga_{vid}"] = {
                "titulo": det.get("informacoes_basicas", {}).get("titulo_vaga", "T√≠tulo n√£o especificado"),
                "cliente": det.get("informacoes_basicas", {}).get("cliente", "Cliente n√£o especificado"),
                "perfil_vaga": {
                    "cidade": perfil.get("cidade", ""),
                    "estado": perfil.get("estado", ""),
                    "pais": perfil.get("pais", ""),
                    "nivel_profissional": perfil.get("nivel_profissional", ""),
                    "nivel_ingles": perfil.get("nivel_ingles", ""),
                    "nivel_espanhol": perfil.get("nivel_espanhol", ""),
                    "competencias": lista_comps,
                    "atividades": lista_atvs
                }
            }

        with open(TARGET_FILE, "w", encoding="utf-8") as f:
            json.dump(jobs_data, f, indent=4, ensure_ascii=False)
        print(f"‚úÖ '{TARGET_FILE}' criado com {len(jobs_data)} vagas reais")
    except Exception as e:
        print(f"‚ùå Erro ao processar '{SOURCE_FILE}': {e}")
        print("Criando dados dummy de fallback...")
        fallback = {
            "vaga_999": {
                "titulo": "Dummy Fallback",
                "cliente": "Sistema",
                "perfil_vaga": {
                    "cidade": "S√£o Paulo",
                    "estado": "SP",
                    "pais": "Brasil",
                    "nivel_profissional": "Pleno",
                    "nivel_ingles": "Intermedi√°rio",
                    "nivel_espanhol": "B√°sico",
                    "competencias": ["Fallback", "Recupera√ß√£o"],
                    "atividades": ["Recuperar sistema", "Manter opera√ß√£o"]
                }
            }
        }
        with open(TARGET_FILE, "w", encoding="utf-8") as f:
            json.dump(fallback, f, indent=4, ensure_ascii=False)
        print(f"‚úÖ '{TARGET_FILE}' criado com dados dummy de fallback")

# 1.5. Cria√ß√£o de um modelo dummy para an√°lise preditiva
dummy_model_data = {
    "experiencia": np.random.randint(0, 5, 100),
    "escolaridade": np.random.randint(0, 7, 100),
    "nivel_ingles": np.random.randint(0, 5, 100),
    "nivel_espanhol": np.random.randint(0, 5, 100),
    "target": np.random.randint(0, 2, 100)
}
df_dummy = pd.DataFrame(dummy_model_data)
X_dummy = df_dummy[["experiencia", "escolaridade", "nivel_ingles", "nivel_espanhol"]]
y_dummy = df_dummy["target"]
modelo = LogisticRegression()
modelo.fit(X_dummy, y_dummy)
joblib.dump(modelo, "modelo_vagas.pkl")
print("‚úÖ 'modelo_vagas.pkl' criado")

"""# --- PARTE 2: FUN√á√ïES AUXILIARES DE DADOS E PR√â-PROCESSAMENTO ---"""

# --- PARTE 2: APLICATIVO STREAMLIT ---
# -*- coding: utf-8 -*-
"""
FIX recrutamento_pro.py - VERS√ÉO CORRIGIDA E EST√ÅVEL PARA DEPLOY
"""

# --- PARTE 1: IMPORTA√á√ÉO DE BIBLIOTECAS E CONFIGURA√á√ïES GLOBAIS ---
import streamlit as st
import pandas as pd
import json
import os
from datetime import datetime
import joblib
import numpy as np
import plotly.express as px
import sqlite3

# --- CONFIGURA√á√ÉO DA P√ÅGINA STREAMLIT ---
st.set_page_config(
    page_title="Plataforma de Vagas - Datathon",
    layout="wide",
    page_icon="üíº"
)

# --- MAPEAMENTOS GLOBAIS ---
EXPERIENCIA_MAP = {
    "Estagi√°rio": 0, "J√∫nior": 1, "Pleno": 2, "S√™nior": 3, "Especialista": 4
}
ESCOLARIDADE_MAP = {
    "Ensino M√©dio": 0, "T√©cnico": 1, "Superior Incompleto": 2,
    "Superior Completo": 3, "P√≥s-gradua√ß√£o": 4, "Mestrado": 5, "Doutorado": 6
}
IDIOMA_MAP = {
    "Nenhum": 0, "B√°sico": 1, "Intermedi√°rio": 2, "Avan√ßado": 3, "Fluente": 4
}

# --- FUN√á√ïES AUXILIARES ---

# Fun√ß√£o para inicializar o banco de dados
def init_db():
    """Inicializa o banco de dados SQLite e a tabela de candidaturas."""
    try:
        conn = sqlite3.connect('candidatos.db')
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS candidaturas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vaga TEXT, nome TEXT, email TEXT, linkedin TEXT,
                experiencia TEXT, escolaridade TEXT, nivel_ingles TEXT,
                nivel_espanhol TEXT, habilidades TEXT, cv TEXT, data_hora DATETIME
            )
        ''')
        conn.commit()
        conn.close()
    except Exception as e:
        st.error(f"Erro ao inicializar o banco de dados: {e}")

# Fun√ß√£o para salvar candidatura no banco de dados
def salvar_candidato_db(dados):
    """Salva uma nova candidatura no banco de dados."""
    try:
        conn = sqlite3.connect('candidatos.db')
        c = conn.cursor()
        dados["data_hora"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute('''
            INSERT INTO candidaturas
            (vaga, nome, email, linkedin, experiencia, escolaridade, nivel_ingles, nivel_espanhol, habilidades, cv, data_hora)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', tuple(dados.values()))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao salvar candidatura no banco de dados: {e}")
        return False

# Fun√ß√£o para carregar todas as candidaturas
def carregar_candidaturas():
    """Carrega todas as candidaturas do banco de dados para um DataFrame."""
    try:
        conn = sqlite3.connect('candidatos.db')
        df = pd.read_sql_query("SELECT * FROM candidaturas", conn)
        conn.close()
        return df
    except Exception as e:
        st.error(f"Erro ao carregar candidaturas: {e}")
        return pd.DataFrame()

# Fun√ß√£o para carregar vagas do arquivo JSON
def carregar_vagas():
    """Carrega os dados das vagas do arquivo jobs_sample.json."""
    try:
        with open("jobs_sample.json", "r", encoding="utf-8") as f:
            data = json.load(f)
        vagas = []
        for vid, det in data.items():
            perfil = det.get("perfil_vaga", {})
            vagas.append({
                "title": det.get("titulo", "T√≠tulo n√£o especificado"),
                "company": det.get("cliente", "Cliente n√£o especificado"),
                "location": f"{perfil.get('cidade', 'N/A')}, {perfil.get('estado', 'N/A')}",
                "description": "; ".join(perfil.get("atividades", [])),
                "requirements": "; ".join(perfil.get("competencias", []))
            })
        return vagas
    except FileNotFoundError:
        st.error("Arquivo 'jobs_sample.json' n√£o encontrado. Crie o arquivo ou fa√ßa o upload.")
        return []
    except Exception as e:
        st.error(f"Erro ao carregar vagas do JSON: {e}")
        return []

# Fun√ß√£o de pr√©-processamento para o modelo
def preprocess(df):
    """Pr√©-processa os dados dos candidatos para a predi√ß√£o do modelo."""
    df2 = df.copy()
    for col, mapping in [
        ("experiencia", EXPERIENCIA_MAP),
        ("escolaridade", ESCOLARIDADE_MAP),
        ("nivel_ingles", IDIOMA_MAP),
        ("nivel_espanhol", IDIOMA_MAP)
    ]:
        if col in df2.columns:
            df2[col] = df2[col].astype(str).map(mapping).fillna(0)
        else:
            df2[col] = 0
    return df2[["experiencia", "escolaridade", "nivel_ingles", "nivel_espanhol"]].astype(int)

# --- INICIALIZA√á√ÉO ---
init_db()

# --- NAVEGA√á√ÉO NA BARRA LATERAL ---
menu = st.sidebar.radio(
    "üìÇ Navega√ß√£o",
    ["üìå Aplicar para Vagas", "üß† Recrutamento Decision", "üìä Banco de Candidaturas"]
)

# --- P√ÅGINA 1: APLICAR PARA VAGAS ---
if menu == "üìå Aplicar para Vagas":
    st.title("üìå Plataforma de Vagas - Datathon")
    vagas = carregar_vagas()

    if vagas:
        escolha_vaga = st.selectbox("Selecione a vaga", options=[v["title"] for v in vagas])
        vaga_selecionada = next((v for v in vagas if v["title"] == escolha_vaga), None)

        if vaga_selecionada:
            st.subheader(vaga_selecionada["title"])
            st.write(f"**Empresa:** {vaga_selecionada['company']} | **Localiza√ß√£o:** {vaga_selecionada['location']}")
            st.write(f"**Descri√ß√£o:** {vaga_selecionada['description']}")
            st.write(f"**Requisitos:** {vaga_selecionada['requirements']}")
            st.write("---")

            # Inicializar session_state para habilidades
            if 'habilidades' not in st.session_state:
                st.session_state.habilidades = []

            with st.form("form_candidatura", clear_on_submit=True):
                st.subheader("Formul√°rio de Candidatura")
                nome = st.text_input("Nome Completo*", placeholder="Seu nome completo")
                email = st.text_input("Email*", placeholder="seu@email.com")
                linkedin = st.text_input("LinkedIn (opcional)", placeholder="https://linkedin.com/in/seu-perfil" )

                col1, col2 = st.columns(2)
                with col1:
                    experiencia = st.selectbox("N√≠vel de Experi√™ncia*", list(EXPERIENCIA_MAP.keys()))
                    escolaridade = st.selectbox("Escolaridade*", list(ESCOLARIDADE_MAP.keys()))
                with col2:
                    nivel_ingles = st.selectbox("Ingl√™s*", list(IDIOMA_MAP.keys()))
                    nivel_espanhol = st.selectbox("Espanhol*", list(IDIOMA_MAP.keys()))

                habilidades_str = st.text_input("Habilidades T√©cnicas (separadas por v√≠rgula)", placeholder="Ex: Python, SQL, Power BI")
                enviar_cv = st.file_uploader("Anexar CV (PDF ou DOCX)", type=["pdf", "docx"])

                submitted = st.form_submit_button("üöÄ Enviar Candidatura")

                if submitted:
                    if not nome or not email:
                        st.error("‚ö†Ô∏è Campos obrigat√≥rios n√£o preenchidos (Nome e Email)")
                    else:
                        dados = {
                            "vaga": escolha_vaga, "nome": nome, "email": email, "linkedin": linkedin,
                            "experiencia": experiencia, "escolaridade": escolaridade,
                            "nivel_ingles": nivel_ingles, "nivel_espanhol": nivel_espanhol,
                            "habilidades": habilidades_str,
                            "cv": enviar_cv.name if enviar_cv else "N√£o enviado"
                        }
                        if salvar_candidato_db(dados):
                            st.success("‚úÖ Candidatura enviada com sucesso!")
                        else:
                            st.error("‚ùå Falha ao salvar a candidatura.")
    else:
        st.warning("Nenhuma vaga dispon√≠vel no momento.")

# --- P√ÅGINA 2: RECRUTAMENTO DECISION ---
elif menu == "üß† Recrutamento Decision":
    st.title("üß† Recrutamento Decision - An√°lise Preditiva")
    uploaded_file = st.file_uploader("Carregue o arquivo CSV de candidatos", type=["csv"])

    if uploaded_file:
        try:
            df = pd.read_csv(uploaded_file)
            st.success("Arquivo carregado com sucesso!")
            st.dataframe(df.head())

            campos_necessarios = ["experiencia", "escolaridade", "nivel_ingles", "nivel_espanhol"]
            if all(c in df.columns for c in campos_necessarios):
                X = preprocess(df)
                st.subheader("Dados Pr√©-processados para An√°lise")
                st.dataframe(X.head())

                if st.button("Executar An√°lise Preditiva"):
                    try:
                        modelo = joblib.load("modelo_vagas.pkl")
                        df["score_sucesso"] = modelo.predict_proba(X)[:, 1]
                        df_ranked = df.sort_values("score_sucesso", ascending=False)
                        
                        st.subheader("üèÜ Ranking de Candidatos")
                        st.dataframe(df_ranked.style.background_gradient(subset=["score_sucesso"], cmap="viridis"))
                        
                        fig = px.histogram(df_ranked, x="score_sucesso", nbins=20, title="Distribui√ß√£o dos Scores de Sucesso")
                        st.plotly_chart(fig)

                        csv_export = df_ranked.to_csv(index=False).encode('utf-8')
                        st.download_button("üì• Exportar Resultados", data=csv_export, file_name="resultados_analise.csv", mime="text/csv")
                    except FileNotFoundError:
                        st.error("Arquivo 'modelo_vagas.pkl' n√£o encontrado. Fa√ßa o upload do modelo.")
                    except Exception as e:
                        st.error(f"Erro na an√°lise preditiva: {e}")
            else:
                st.warning(f"‚ö†Ô∏è O arquivo precisa conter as colunas: {', '.join(campos_necessarios)}")
        except Exception as e:
            st.error(f"Erro ao ler o arquivo CSV: {e}")

# --- P√ÅGINA 3: BANCO DE CANDIDATURAS ---
elif menu == "üìä Banco de Candidaturas":
    st.title("üìä Banco de Candidaturas")
    df_candidaturas = carregar_candidaturas()

    if not df_candidaturas.empty:
        st.dataframe(df_candidaturas.sort_values("data_hora", ascending=False))
        
        col1, col2 = st.columns(2)
        col1.metric("Total de Candidaturas", len(df_candidaturas))
        col2.metric("Vagas √önicas com Aplica√ß√µes", df_candidaturas["vaga"].nunique())

        csv_export = df_candidaturas.to_csv(index=False).encode('utf-8')
        st.download_button("üì• Exportar Dados Completos", data=csv_export, file_name="candidaturas_completas.csv", mime="text/csv")
    else:
        st.info("Nenhuma candidatura registrada no banco de dados ainda.")



# --- PARTE 3: CONFIGURA√á√ÉO DO NGROK (CORRIGIDO) ---
import subprocess
import time
from pyngrok import ngrok
import os

# Token Ngrok - INSIRA SEU TOKEN AQUI!
NGROK_AUTH_TOKEN = "2wQHkXBUOtRPz53cch40jRcY9Z9_6M18JDPPBPT9XqCfsKHkP"

if not NGROK_AUTH_TOKEN:
    print("ERRO: Insira seu token Ngrok na vari√°vel NGROK_AUTH_TOKEN")
else:
    try:
        # Configurar autentica√ß√£o
        ngrok.set_auth_token(NGROK_AUTH_TOKEN)

        # Salvar o aplicativo Streamlit em um arquivo
        STREAMLIT_SCRIPT = "streamlit_app.py"
        with open(STREAMLIT_SCRIPT, "w", encoding="utf-8") as f:
            # (O conte√∫do do seu script streamlit vai aqui, mantido como est√°)
            f.write("""
# --- STREAMLIT APP SCRIPT ---
import streamlit as st
import pandas as pd
import json
import os
from datetime import datetime
import joblib
import plotly.express as px
import sqlite3

# Configura√ß√£o da p√°gina
st.set_page_config(page_title="Plataforma de Vagas - Datathon", layout="wide")

# Mapeamentos globais
experiencia_map = {"Estagi√°rio": 0, "J√∫nior": 1, "Pleno": 2, "S√™nior": 3, "Especialista": 4}
escolaridade_map = {
    "Ensino M√©dio": 0, "T√©cnico": 1, "Superior Incompleto": 2,
    "Superior Completo": 3, "P√≥s-gradua√ß√£o": 4, "Mestrado": 5, "Doutorado": 6
}
idioma_map = {"Nenhum": 0, "B√°sico": 1, "Intermedi√°rio": 2, "Avan√ßado": 3, "Fluente": 4}

# Fun√ß√£o para salvar candidatura
def salvar_candidato_db(dados):
    try:
        conn = sqlite3.connect('candidatos.db')
        c = conn.cursor()
        dados["data_hora"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c.execute('''
            INSERT INTO candidaturas
            (vaga, nome, email, linkedin, experiencia, escolaridade, nivel_ingles, nivel_espanhol, habilidades, cv, data_hora)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (dados['vaga'], dados['nome'], dados['email'], dados['linkedin'], dados['experiencia'],
              dados['escolaridade'], dados['nivel_ingles'], dados['nivel_espanhol'],
              dados['habilidades'], dados['cv'], dados['data_hora']))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        st.error(f"Erro ao salvar candidatura: {str(e)}")
        return False

# Fun√ß√£o para carregar vagas
def carregar_vagas():
    try:
        with open("jobs_sample.json", "r", encoding="utf-8") as f:
            data = json.load(f)
        vagas = []
        for vid, det in data.items():
            perfil = det["perfil_vaga"]
            vagas.append({
                "title": det["titulo"],
                "company": det["cliente"],
                "location": f"{perfil['cidade']}, {perfil['estado']} - {perfil['pais']}",
                "contract_type": "N√£o informado",
                "salary": "N√£o informado",
                "description": "; ".join(perfil.get("atividades", [])),
                "requirements": "; ".join(perfil.get("competencias", []))
            })
        return vagas
    except Exception as e:
        st.error(f"Erro ao carregar vagas: {e}")
        return []

# Fun√ß√£o de pr√©-processamento ATUALIZADA
def preprocess(df):
    df2 = df.copy()
    for col in ["experiencia", "escolaridade", "nivel_ingles", "nivel_espanhol"]:
        if col in df2.columns:
            df2[col] = df2[col].astype(str)
    for col, mapping in [
        ("experiencia", experiencia_map),
        ("escolaridade", escolaridade_map),
        ("nivel_ingles", idioma_map),
        ("nivel_espanhol", idioma_map)
    ]:
        if col in df2.columns:
            df2[col] = df2[col].map(lambda x: mapping.get(x.strip(), 0))
        else:
            df2[col] = 0
    return df2[["experiencia", "escolaridade", "nivel_ingles", "nivel_espanhol"]].fillna(0).astype(int)

# Navega√ß√£o
menu = st.sidebar.radio("üìÇ Navega√ß√£o", ["üìå Aplicar para Vagas", "üß† Recrutamento Decision", "üìä Banco de Candidaturas"])

if menu == "üìå Aplicar para Vagas":
    st.title("üìå Plataforma de Vagas - Datathon")
    vagas = carregar_vagas()
    if vagas:
        escolha = st.selectbox("Selecione a vaga", options=[v["title"] for v in vagas])
        vaga = next(v for v in vagas if v["title"] == escolha)
        st.subheader(vaga["title"])
        st.write(f"**Empresa:** {vaga['company']}")
        st.write(f"**Localiza√ß√£o:** {vaga['location']}")
        st.write(f"**Descri√ß√£o:** {vaga['description']}")
        st.write(f"**Requisitos:** {vaga['requirements']}")
        if 'habilidades' not in st.session_state:
            st.session_state.habilidades = []
        for field in ['nome', 'email', 'linkedin', 'experiencia', 'escolaridade', 'nivel_ingles', 'nivel_espanhol']:
            if field not in st.session_state:
                st.session_state[field] = ''
        with st.form("form_candidatura"):
            st.subheader("Formul√°rio de Candidatura")
            nome = st.text_input("Nome Completo*", value=st.session_state.nome)
            email = st.text_input("Email*", value=st.session_state.email)
            linkedin = st.text_input("LinkedIn (opcional)", value=st.session_state.linkedin)
            experiencia = st.selectbox("N√≠vel de Experi√™ncia*", list(experiencia_map.keys()), index=list(experiencia_map.keys()).index(st.session_state.experiencia) if st.session_state.experiencia in experiencia_map else 0)
            escolaridade = st.selectbox("Escolaridade*", list(escolaridade_map.keys()), index=list(escolaridade_map.keys()).index(st.session_state.escolaridade) if st.session_state.escolaridade in escolaridade_map else 0)
            nivel_ingles = st.selectbox("Ingl√™s*", list(idioma_map.keys()), index=list(idioma_map.keys()).index(st.session_state.nivel_ingles) if st.session_state.nivel_ingles in idioma_map else 0)
            nivel_espanhol = st.selectbox("Espanhol*", list(idioma_map.keys()), index=list(idioma_map.keys()).index(st.session_state.nivel_espanhol) if st.session_state.nivel_espanhol in idioma_map else 0)
            st.subheader("Habilidades T√©cnicas")
            nova_habilidade = st.text_input("Digite uma habilidade e clique em Adicionar", placeholder="Ex: Python, SQL, etc.")
            col_add, col_clear = st.columns(2)
            with col_add:
                adicionar_habilidade = st.form_submit_button("‚ûï Adicionar Habilidade")
            with col_clear:
                limpar_habilidades = st.form_submit_button("üßπ Limpar Todas")
            if adicionar_habilidade and nova_habilidade:
                st.session_state.habilidades.append(nova_habilidade.strip())
                st.rerun()
            if limpar_habilidades:
                st.session_state.habilidades = []
                st.rerun()
            if st.session_state.habilidades:
                st.write("**Habilidades adicionadas:**")
                for i, hab in enumerate(st.session_state.habilidades):
                    st.write(f"{i+1}. {hab}")
            enviar_cv = st.file_uploader("CV (PDF ou DOCX)")
            submitted = st.form_submit_button("Enviar Candidatura")
            if submitted:
                if not nome or not email:
                    st.error("Campos obrigat√≥rios n√£o preenchidos (Nome e Email)")
                else:
                    dados = {"vaga": escolha, "nome": nome, "email": email, "linkedin": linkedin, "experiencia": experiencia, "escolaridade": escolaridade, "nivel_ingles": nivel_ingles, "nivel_espanhol": nivel_espanhol, "habilidades": ", ".join(st.session_state.habilidades) if st.session_state.habilidades else "Nenhuma", "cv": enviar_cv.name if enviar_cv else "Nenhum"}
                    if salvar_candidato_db(dados):
                        st.success("‚úÖ Candidatura enviada com sucesso!")
                        st.session_state.habilidades = []
                        st.session_state.nome = nome
                        st.session_state.email = email
                        st.session_state.linkedin = linkedin
                        st.session_state.experiencia = experiencia
                        st.session_state.escolaridade = escolaridade
                        st.session_state.nivel_ingles = nivel_ingles
                        st.session_state.nivel_espanhol = nivel_espanhol
                    else:
                        st.error("‚ùå Erro ao salvar candidatura no banco de dados")
    else:
        st.info("Nenhuma vaga dispon√≠vel. Verifique 'jobs_sample.json'.")
elif menu == "üß† Recrutamento Decision":
    st.title("üß† Recrutamento Decision - An√°lise Preditiva")
    uploaded = st.file_uploader("Upload do CSV de candidatos aplicados", type="csv")
    if uploaded:
        df = pd.read_csv(uploaded)
        st.success("Arquivo carregado!")
        st.dataframe(df.head())
        faltam = [c for c in ["experiencia","escolaridade","nivel_ingles","nivel_espanhol"] if c not in df.columns]
        if faltam:
            st.warning(f"Campos faltantes: {', '.join(faltam)}")
        st.subheader("Pr√©-processamento")
        X = preprocess(df)
        st.dataframe(X.head())
        if st.button("Analisar com Modelo"):
            try:
                mdl = joblib.load("modelo_vagas.pkl")
                df["score_sucesso"] = mdl.predict_proba(X)[:,1]
                st.subheader("üèÜ Ranking de Candidatos")
                st.dataframe(df.sort_values("score_sucesso", ascending=False))
                st.subheader("üìä Distribui√ß√£o de Scores")
                fig = px.histogram(df, x="score_sucesso", nbins=10)
                st.plotly_chart(fig)
                st.download_button("Exportar resultados", data=df.to_csv(index=False).encode("utf-8"), file_name="resultado_candidatos.csv", mime="text/csv")
            except Exception as e:
                st.error(f"Erro ao rodar modelo: {e}")
elif menu == "üìä Banco de Candidaturas":
    st.title("üìä Banco de Candidaturas")
    try:
        conn = sqlite3.connect('candidatos.db')
        df = pd.read_sql_query("SELECT * FROM candidaturas", conn)
        conn.close()
        if not df.empty:
            st.dataframe(df)
            st.download_button("Exportar para CSV", data=df.to_csv(index=False).encode('utf-8'), file_name="candidaturas_completas.csv", mime="text/csv")
        else:
            st.info("Nenhuma candidatura encontrada no banco de dados")
    except Exception as e:
        st.error(f"Erro ao acessar banco de dados: {e}")
""")

        # Iniciar o Streamlit em segundo plano
        print("‚è≥ Iniciando servidor Streamlit...")
        process = subprocess.Popen([
            "streamlit", "run", STREAMLIT_SCRIPT,
            "--server.port", "8501",
            "--server.headless", "true",
            "--server.enableCORS", "false",
            "--server.enableXsrfProtection", "false"
        ])

        # Esperar inicializa√ß√£o
        time.sleep(8)

        # Criar t√∫nel Ngrok
        print("‚è≥ Criando t√∫nel Ngrok...")
        public_url = ngrok.connect(addr="8501", proto="http", bind_tls=True )

        # Exibir link de acesso
        print("\n" + "="*50)
        print(f"üåü APLICATIVO PUBLICADO COM SUCESSO!")
        print("="*50)
        print(f"üîó ACESSE EM: {public_url.public_url}")
        print("="*50)
        print("Este link √© v√°lido enquanto esta sess√£o estiver ativa")
        print("Para desativar, interrompa a execu√ß√£o do notebook")

        # Manter o processo ativo (ESTRUTURA CORRIGIDA)
        try:
            while True:
                time.sleep(10)
                print(f"‚úÖ Aplicativo ativo em: {public_url.public_url}")
                print("Pressione Ctrl+C para encerrar")
        except KeyboardInterrupt:
            print("\nEncerrando aplicativo...")
            process.terminate()
            ngrok.kill()
            os.remove(STREAMLIT_SCRIPT)

    except Exception as e:
        print(f"Erro na configura√ß√£o: {str(e)}")
        print("Certifique-se de que o token Ngrok est√° correto!")
